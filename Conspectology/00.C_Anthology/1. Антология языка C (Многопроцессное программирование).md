 Этот большой раздел будет посвящён основным функциям языка С, необходимым для работы в _многопроцессорных_ программах. Здесь будут собраны материалы по созданию родственных процессов, работе с ними и организации взаимодействия между ними. Немножко теории ОСей, объясняющей происходящее; немножко теории С, а также задачки, на примерах которых мы будем разбирать работу функций. 

# Многопроцессная обработка

#### Общая теория

В зависимости от контекста под словом "Процесс" могут понимать сразу несколько вещей. Процесс в смысле некой единицы, с которой работает процессор, - это совокупность машинных команд и данных, обрабатываемая в вычислительной системе и обладающая правами на владение некоторым набором ресурсов ВС. Если переводить этот термин с умного на человеческий, процесс - это отдельный логический объект, выполняющий свою отдельную программу (набор команд), имеющий свой отдельный набор данных и способный обращаться к ОС, чтобы какие-то ещё данные и ресурсы у неё брать.

Различают _Полновесные_ и _Легковесные_ процессы. Полновесные (их мы и будем в дальнейшем называть _процессами_) обладают собственным виртуальным адресным пространством, недоступным для других процессов. Легковесные (их мы будем называть _нити_) принадлежат каким-то полновесным процессам, находятся в их виртуальном адресном пространстве и, соответственно, конкурируют за данные внутри процесса друг с другом. Мы уделим отдельную главу для работы с нитями и продолжим здесь описывать лишь полновесные процессы.

Все процессы регистрируются в таблице процессов ОС. По ней ведётся учёт выделенных ресурсов для каждого процесса. Нулевой процесс определяет саму ОС, первый процесс `init` является основным инициализирующим процессом системы. Каждый процесс в соответствии с таблицей процессов получает свой уникальный идентификатор `PID`. 

Узнать идентификатор текущего процесса можно с помощью команды `getpid()`, идентификатор родительского процесса - `getppid()`

Каждая запись таблицы процессов имеет ссылку на _контекст процесса_, который структурно состоит из пользовательской, системной и аппаратной составляющих.

1. Программная составляющая (лежит в адресном пространстве процесса):
	 + Сегмент кода
	 + Сегмент данных
2. Аппаратная составляющая (лежит в адресном пространстве ядра):
	 + Регистры
	 + Счётчик команд
3. Системная составляющая (лежит в адресном пространстве ядра):
	 + `PPID` - идентификатор процесса-родителя
	 + Диспозиция сигналов
	 + Таблица открытых файлов процесса
	 + Реальный идентификатор пользователя процесса (РИПП)
	 + Эффективный идентификатор пользователя процесса (ЭИПП)

#### Запуск программ

Для запуска процесса с какой-то конкретной программой используются системные вызовы семейства `exec`. Такой СВ заменяет весь текущий процесс на новый указанный

При этом в процессе наследуются
 - `PID`
 - `PPID`
 - Таблица открытых файлов

И не наследуются:
  - Сегменты кода и данных
  - Диспозиция сигналов

Оно и логично: процесс остаётся тем же, а вот данные, которыми он оперирует и которые обрабатывает (типа сигналов) меняются.

Библиотека для работы:
```c
#include <unistd.h>
```

 + если точно знаем, какие параметры приходят
```c
execl(const char* path, char* argv0, char* argv1..., char* argvN, NULL);
execlp(const char* file, char* argv0, char* argv1..., char* argvN, NULL);
execle(const char* path, char* argv0, char* argv1..., char* argvN, NULL, char** envp);
```

+ если не знаем параметры явно, формируем массив строк-параметров, заканчивающийся `NULL`
```c
execv(const char* path, char** argv);
execvp(const char* file, char** argv);
execve(const char* path, char** argv, char** envp);
```
 
`path` - полное имя
`file` - короткое имя, ищется в директории
`envp` - массив втрок переменных окружения

```c
execlp("ls", "ls", "-l", NULL);

char* m[] = {"gcc", "a.c", "-o", "out", NULL};
execvp("gcc", m);
```

Помним, что `argv0` должен совпадать с именем программы
Кроме того, так как `exec` заменяет весь процесс, исполнение команд, идущих после его вызова - ошибка, которую нужно обрабатывать
```c
  execl(...);
  _exit(1);
```

Пример: **Напишите простейшую программу подмены процесса на заданную в аргументах командной строки функцию**

`exec.c`
```c
#include <unistd.h>

int
main(int argc, char** argv)
{
	if (argc == 1) {
		return 0;
	}

	execvp(argv[1], argv + 1);
	_exit(1);
}
```

```console
stephen@localhost:path/to/somewhere> gcc exec.c -o exec
stephen@localhost:path/to/somewhere> ./exec echo Hello
Hello
stephen@localhost:path/to/somewhere> 
```
#### Создание параллельного процесса

Единовременно процесс может обрабатывать только одну последовательность команд. Соответственно для бесперебойной обработки приходящих запросов на исполнение программ нам необходим алгоритм создания параллельных процессов для запуска в них приходящих задач.

Системный вызов создания сыновьего процесса хранится в библиотеке `unistd.h` и называется
```c
pid_t fork();
```

СВ делает запрос к ОС на создание процесса и возвращает:
 + -1 при ошибке
 + 0 при успехе сыну
 + `PID` сына при успехе отцу

```c
pid_t pid = fork();

if (pid < 0) {
  exit(1);
} else if (!pid) { // son
  printf("%d %d\n", getpid(), getppid());
} else { // father
  printf("%d %d\n", pid, getpid());    //выведет то же самое
}
```

При создании параллельного процесса наследуются:
 + Диспозиция сигналов
 + Сегменты кода и данных
 + Таблица открытых файлов

И не наследуются:
 + `PID`
 + `PPID`

`fork()` делает снапшот (snapshot, копию состояния) процесса-родителя и переносит её в другое адресное пространство, выделенное под процесс-сын

```
      |
	a = 5;
	  |
    fork()
      /\ 
   0 /  \ pid > 0
    /    \
сын       отец
a = 5;    a = 5;
```

Так как в новый процесс переносится и копия ТОФ процесса-родителя, оба процесса начинают управлять одним и тем же указателем ввода-вывода и устраивать _гонку за ресурс_

`a.txt`
```a.txt
abcd
```

```c
int fd = open("a.txt", O_RDONLY);
char c;
pid_t pid = fork();

if (!pid) {
  read(fd, &c, 1);
  putchar(c);
} else {
  read(fd, &c, 1);
  putchar(c);
}
```

Будет `ab` или `ba`

Чтобы гонки не происходило, нужно открывать файлы после создания процесса

```c
char c;
pid_t pid = fork();

if (!pid) {
  int fd1 = open("a.txt", O_RDONLY);
  read(fd1, &c, 1); // напечатает 'a'
  putchar(c);
} else {
  int fd2 = open("a.txt", O_RDONLY);
  read(fd2, &c, 1); // напечатает 'a'
  putchar(c);
}
```

#### Обработка окончания работы процесса

При работе с сыновьими процессами возникает необходимость обрабатывать завершение окончания их работы. Для этого существуют отдельные системные вызовы.

При завершении алгоритма обработки процесс не исчезает, а помечается, как завершённый, и ожидает, когда его завершат внешним действием (такое состояние называется "процессом-зомби")

Библиотека с системными вызовами
```c
#include <sys/wait.h>
```

 Системные вызовы обработки окончания пишутся в отцовском процессе и ожидают окончания сыновьего процесса


```c
pid_t wait(int* status);
```

  + Ожидает любого процесса, который раньше кончится
 - Если к моменту вызова нет закончившихся процессов, но есть исполняющийся, то ждёт его окончания
 - Если нет процессов, которые надо ждать, возвращает -1 (поэтому никто не запретит нам писать `wait` в любых процессах. Просто в тех, у которых нет сыновьих, он не сыграет никакой роли)
 - При успехе (завершении сыновьего процесса) возвращает `PID` сыновьего и, если `status != NULL`, записывает в `status` код окончания процесса
```
status |            |           |
		Программный   Системный
		код           код
		окончания     окончания
```

```c
pid_t waitpid(pid_t pid, int* status, int fl);
```

```
pid:
    > 0 - Ждёт указанного
    -1 - ждёт любого
    = 0 - Ждёт с тем же id группы

fl:
    WNOHANG - Если сыновий не закончился, то не ждёт его, а продолжает работу(хорошо в цикле поставить)
```


Для обработки окончания процесса существуют макросы, проверяющие код окончания `status`

`WIFEXITED(status)` - Если != 0, то "Сигнал не прерван", можно смотреть программный код окончания
`WEXITSTATUS(status)` - возвращает программный код окончания (Корректное окончание программы по умолчанию 0)

Успешное окончание процесса: 
```c
WIFEXITED(status) && !WEXITSTATUS(status)
```
Неуспешное окончание процесса:
```c
!WIFEXITED(status) || WEXITSTATUS(status)
```

`WIFSIGNALED(status)` - Если != 0, то "Прерван сигналом"
`WTERMSIG(signal)` - возвращает номер сигнала(системный код окончания)


Пример: **В аргументах командной строки подаются названия программ без аргументов (н-р, "ls" или "a.out"). Запустить все программы сначала параллельно, затем последовательно в сыновьих процессах, посчитать количество корректно завершившихся в обоих случаях. Отцовский процесс должен закончить работу позже всех своих сыновей**

`fork_exec.c`
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int
main(int argc, char** argv)
{
    int count_of_parallel_problems = 0;
    int count_of_sequence_problems = 0;
    
    printf("Parallel\n");
    for (int i = 1; i < argc; i++) {
        pid_t pid_parallel = fork();

        if (pid_parallel < 0) {
            continue;
        }else if (!pid_parallel) {
            execlp(argv[i], argv[i], NULL);
            _exit(1);
        }
    }

    int status_parallel;
    while (wait(&status_parallel) != -1) {
        
        if (WIFEXITED(status_parallel) && !WEXITSTATUS(status_parallel)) {
            count_of_parallel_problems++;
        }
    }

    printf("sequence\n");
    for (int i = 1; i < argc; i++) {
        pid_t pid_sequence = fork();

        if (pid_sequence < 0) {
            _exit(1);
        } else if (!pid_sequence) {
            execlp(argv[i], argv[i], NULL);
            _exit(1);
        } else {
            int status_sequence;
            waitpid(pid_sequence, &status_sequence, 0);

            if (WIFEXITED(status_sequence) && !WEXITSTATUS(status_sequence)) {
                count_of_sequence_problems++;
            }
        }
    }

    printf("%d\n", count_of_parallel_problems);
    printf("%d\n", count_of_sequence_problems);
    return 0;
}
```

```console
stephen@localhost:path/to/somewhere> gcc fork_exec.c -o fork_exec
stephen@localhost:path/to/somewhere> ./fork_exec ls cal date
Parallel
Thu Oct 24 09:22:24 AM MSK 2024
exec  exec.c  fork_exec  fork_exec.c
    October 2024    
Su Mo Tu We Th Fr Sa
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30 31      
                    
sequence
exec  exec.c  fork_exec  fork_exec.c
    October 2024    
Su Mo Tu We Th Fr Sa
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30 31      
                    
Thu Oct 24 09:22:24 AM MSK 2024
3
3
stephen@localhost:path/to/somewhere>
```


# Неименованные каналы

#### Общая теория

`Pipe` - неименованный канал - это кольцевой буфер, который представляется системой в виде области памяти, управляемой ОС. Неименованный канал используется в качестве разделяемого ресурса памяти для близкородственных процессов, оперирующих копиями одной и той же ТОФ.

При создании канала для буфера в ТОФ заводится два файловых дескриптора - отдельно на чтение и на запись. После создания канала можно создавать сыновьи процессы, и доступ к каналу будет передаваться к ним вместе с ТОФ (но, логично, оперировать все они будут одним указателем ввода-вывода)

```c
#include <unistd.h>
int pipe(int fd[2]);
```

```
fd[0] - чтение из буфера
fd[1] - запись в буфер

-->|                |-
|--------------------|

0 - OK
-1 - error
```

Неименованный канал обрабатывается, как поток байт, к которому применимы низкоуровневые системные вызовы ввода-вывода `read` и `write`

Особенности обработки ввода-вывода при работе с неименованным каналом:

1. Если канал пуст и в него вызвана команда `read`:
  + Если ВСЕ дескрипторы по записи ЗАКРЫТЫ (даже свой) - вернёт 0(конец файла)
  + Если хотя бы один открыт (даже свой) - процесс блокируется и ждёт данных (т.е. можно сломать самого себя, если забыть свой дескриптор на запись закрыть)

2. Если канал полон и в него вызвана команда `write`:
 + Если хотя бы один дескриптор по чтению открыт (даже свой) - процесс блокируется и ждёт свободного места (т.е. можно сломать самого себя, если забыть свой дескриптор на чтение закрыть)
 + Если ВСЕ дескрипторы по чтению ЗАКРЫТЫ (даже свой) - прерывание процесса по сигналу `SIGPIPE`.

Пример: 
**Реализовать иерархию процессов**
  ```
A - c1 - b1
  - c2 - b2
```
**Сделать так, чтобы** `b2` **печатал** `PID c1`,  **а** **`b1` **печатал** `PID c2`. **Родительские процессы завершаются после всех своих сыновьих процессов**

`pipe.c`
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int
main(int argc, char** argv)
{
    pid_t pid;
    int fd12[2];
    int fd21[2];

    if (pipe(fd12) < 0) {
        return -1;
    }
    if (pipe(fd21) < 0) {
        return -1;
    }

    if ((pid = fork()) < 0) {
        return -2;
    } else if (!pid) {
        int c1_pid = getpid();
        printf("Im c1, my pid is %d\n", c1_pid);
        
        if ((pid = fork()) < 0) {
            return -5;
        } else if (!pid) {
            int c2_pid_result, c1_pid = getppid();
            
            close(fd12[1]);
            if (read(fd12[0], &c2_pid_result, sizeof(c2_pid_result)) != sizeof(c2_pid_result)) {
                return 1;
            }
            close(fd12[0]);

            close(fd21[0]);
            if (write(fd21[1], &c1_pid, sizeof(c1_pid)) != sizeof(c1_pid)) {
                return 1;
            }
            close(fd21[1]);

            printf("Im b1, c2_pid = %d\n", c2_pid_result);
            return 0;
        }

        close(fd12[0]);
        close(fd12[1]);
        close(fd21[0]);
        close(fd21[1]);

        wait(NULL);
        return 0;

    }

    if ((pid = fork()) < 0) {
        return -2;
    } else if (!pid) {
        int c2_pid = getpid();
        printf("Im c2, my pid is %d\n", c2_pid);
        
        if ((pid = fork()) < 0) {
            return -5;
        } else if (!pid) {
            int c1_pid_result, c2_pid = getppid();
            
            close(fd12[0]);
            if (write(fd12[1], &c2_pid, sizeof(c2_pid)) != sizeof(c2_pid)) {
                return 1;
            }
            close(fd12[1]);

            close(fd21[1]);
            if (read(fd21[0], &c1_pid_result, sizeof(c1_pid_result)) != sizeof(c1_pid_result)) {
                return 1;
            }
            close(fd21[0]);

            printf("Im b2, c1_pid = %d\n", c1_pid_result);
            return 0;
        }

        close(fd12[0]);
        close(fd12[1]);
        close(fd21[0]);
        close(fd21[1]);

        wait(NULL);
        return 0;

    }

    int status;
    while(wait(&status) != -1);
    
    return 0;
}
```

```console
stephen@localhost:path/to/somewhere> gcc pipe.c -o pipe
stephen@localhost:path/to/somewhere> ./pipe 
Im c1, my pid is 125654
Im c2, my pid is 125655
Im b1, c2_pid = 125655
Im b2, c1_pid = 125654
stephen@localhost:path/to/somewhere>
```

#### Конвейеры

В терминале при работе с программами можно перенаправлять потоки ввода-вывода данных и строить [конвейеры](https://github.com/UsamG1t/Methodics_of_LinuxAppDev/tree/master/Methodical_manual/03_Text)
Пример команды: `pr < file1 >> file2 2> file3`

 + `<` - далее пишется поток ввода (откуда читать)
 + `>` - далее пишется поток вывода (куда писать ответ)
 + `2>` - далее пишется поток ошибок (куда писать логи и ошибки)
 + `>>` - также поток вывода, однако если предыдущий вариант переписывает данные в итоговом месте (пишет поверх уже имеющихся данных или затирает файл и после пишет в пустой), то такой формат дописывает данные в конец потока
 + `|` — конвейер, вывод левого операнда передаётся на вход правому операнду


Для программирования конвейеров и настройки потоков нужно перенаправлять ввод и вывод в свои каналы

```c
int dup(int old); // приравнивает результатом функции дескриптор
int dup2(int old, int new); // подменяет второй первым
```

Пример:

`a.txt`
```a.txt
abc
```

```c
int fd = open("aaa", RDONLY);
int new = dup(fd);
// оба дескриптора на один указатель таблицы файлов

read(fd, &c, 1); // вернёт a
read(new, &c, 1); // вернёт b
```

В случае `dup2` мы подменяем указатель по второму дескриптору на значение, хранящееся в первом (буквально из первого во второй копируем указатель, оба дескриптора будут указывать на структуру из первого). Главное, не заывать закрывать продублированные дескрипторы, чтобы не попасть в ловушку самоблокировки.

```c
dup2(fd, 0); // подменили stdin
close(fd); // не забываем закрыть дескриптор
```

Пример: **В аргументах командной строки подаётся два исполняемых файла, необходимо создать конвейер**

`io_pipe.c`
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int
main(int argc, char** argv)
{
    if (argc < 3) {
        return -1;
    }
    
    int fd[2];
    
    if (pipe(fd) < 0) {
        return -2;
    }

    pid_t pid;

    if ((pid = fork()) < 0) {
        return -3;
    } else if (!pid){
        close(fd[0]);
        dup2(fd[1], 1);
        close(fd[1]);

        execlp(argv[1], argv[1], NULL);
        _exit(1);
    }
    
    if ((pid = fork()) < 0) {
        return -4;
    } else if (!pid) {
        close(fd[1]);
        dup2(fd[0], 0);
        close(fd[0]);

        execlp(argv[2], argv[2], NULL);
        _exit(1);
    }

    close(fd[0]);
    close(fd[1]);

    int status;
    while(wait(&status) != -1);
    
    return 0;
}
```

```console
stephen@localhost:path/to/somewhere> gcc io_pipe.c -o io_pipe
stephen@localhost:path/to/somewhere> ls | wc
      8       8      64
stephen@localhost:path/to/somewhere> ./io_pipe ls wc
      8       8      64
stephen@localhost:path/to/somewhere>
```


Пример: **В аргументах командной строки подаются 4 исполняемых файла, необходимо реализовать команду** `pr < file1 >> file2 2> file3`, **при создании файлов делать права 0600**

`shell.c`
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int
main(int argc, char** argv)
{
    if (argc < 5) {
        return -1;
    }

    pid_t pid;

    if ((pid = fork()) < 0) {
        return -2;
    } else if (!pid) {
        int fd0 = open(argv[2], O_RDONLY);
        int fd1 = open(argv[3], O_CREAT | O_WRONLY | O_APPEND, 0600);
        int fd2 = open(argv[4], O_CREAT | O_TRUNC | O_WRONLY, 0600);

        dup2(fd0, 0);
        dup2(fd1, 1);
        dup2(fd2, 2);

        close(fd0);
        close(fd1);
        close(fd2);

        execlp(argv[1], argv[1], NULL);
        _exit(1);
    }

    int status;
    while(wait(&status) != -1);
    
    return 0;
}
```

```console
stephen@localhost:path/to/somewhere> ls > in.txt
stephen@localhost:path/to/somewhere> wc < in.txt 
10 10 79
stephen@localhost:path/to/somewhere> gcc shell.c -o shell
stephen@localhost:path/to/somewhere> ./shell wc in.txt out.txt err.txt
stephen@localhost:path/to/somewhere> cat out.txt 
10 10 79
stephen@localhost:path/to/somewhere> cat err.txt 
stephen@localhost:path/to/somewhere> 
```


# Сигналы

#### Общая теория

_Сигналы_ - специальные реакции на действия пользователя/ОС
В процессе хранится своя маска сигналов (в большинстве систем она занимает 32 бита), по приходе сигнала соответствующий ему бит отмечается, и при отлавливании запускается процесс обработки этого сигнала. Если одновременно приходят несколько различных сигналов, порядок их обработки не определен. Если же обработки ждут несколько одинаковых сигналов, то формат обработки - будет это воспринято, как один сигнал или как множество одинаковых, - зависит от ОС.

Все основные сигналы и основные функции работы с ними сосредоточены в библиотеке

```c
#include <signal.h>
```

```
sig:
	SIGKILL - убийство процесса, не может быть перехвачен (дойдёт и убьёт)
	SIGINT - Ctrl+C
	SIGCHLD - то, что ждёт отец от завершённого сына
	SIGALARM - будильник, alarm(sec)
	SIGPIPE - Приходит процессу, который пишет в канал, тот переполняется, а читающих из канала нет
	SIGUSR1 - } 
	SIGUSR2 - } - зарезервированные пользовательские
```

```c
int kill(pid_t pid, int sig) // отправить сигнал процессу
```


#### Перехват сигналов

Для обработки сигналов в библиотеке есть специальный системный вызов
```c
void(*signal(int sig, void(*f)(int) ) )(int); 
//возвращает предыдущую реакцию на сигнал, подменяет реакцию на пользовательскую
					// SIG_DFL - вернёт дефолтную реакцию на сигнал
					// SIG_IGN - будет игнорировать сигнал
```
Этот системный вызов принимает первым параметром принимает обрабатываемый сигнал, а вторым параметром указывается функция-обработчик прерывания или соответствующий флаг (см.выше)

Схема работы перехвата:
Установили "Ловушку" -> Получили сигнал -> Прервали программу, которая сейчас работает -> сбросили "ловушку" -> отработали функцию-обработчик -> вернулись в прерванную программу

При этом прерывание может прервать нашу программу-обработчик прерывания. И тогда сначала отработает новое прерывание, потом старое, потом произойдёт возврат в основную программу.

Как видно из схемы работы перехвата, наш обработчик сигналов "одноразовый" - для отлова каждого нового прихода сигнала необходимо вновь делать обращение системным вызовом, иначе сигнал будет обрабатываться по умолчанию. 

Пример: **Прервать программу на 5ое Ctrl+C**

`signal.c`
```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

volatile int count = 0;

void(*prev)(int);

void
handler(int sig) {
    signal(SIGINT, handler);
    printf("%d\n", ++count);

    if (count == 4) {
        signal(SIGINT, prev);   // - восстанавливаем предыдущую реакцию(вдруг там была не дефолтная)
    }
    
    return;
}

int
main(int argc, char** argv)
{
    prev = signal(SIGINT, handler);
    while(1) pause(); // pause ждёт любого сигнала
    return 0;
}
```

```console
stephen@localhost:path/to/somewhere> gcc signal.c -o signal
stephen@localhost:path/to/somewhere> ./signal 
^C1
^C2
^C3
^C4
^C
stephen@localhost:path/to/somewhere>
```

Для того, чтобы задать параметры обработки сигналов без постоянного переопределения, можно воспользоваться системным вызовом `sigaction` исвязанной с ним структурой `struct sigaction`

```c
int sigaction(int sig, struct sigaction *act, struct sigaction *old);

int sig - сигнал
struct sigaction *act - реакция на сигнал
struct sigaction *old - предыдущая реакция (NULL, если нам нужен SIG_DFL) 

struct sigaction {
	...
	void(*sa_handler)(int);
	int sa_flags;           // Ставим сюда SA_RESTART, тогда будет само себя перезаписывать
}
```

С использованием этого СВ прошлую задачу можно было бы сделать так:


 + ставим вместо `signal` в `main`
```c
sigaction(SIGINT, &(struct sigaction) { .sa_handler = handler, .sa_flags = SA_RESTART}, NULL);
```   
 + убираем из `handler` первую строку

_**TODO**_: написать программу через `sigaction`

#### Надёжные сигналы

Надёжная обработка сигнала заключается в удержании процесса в блокировке до получения сигнала, а также искоренении "слипания" одинаковых сигналов (если пришло 3 одинаковых, то все 3 будут обработаны)

Для этого кроме задания обработчика сигналов необходимо задавать маску сигналов, которые будут отлавливаться. Для этого в `signal.h` есть отдельный набор функций и типов переменных:
```c
int sigemptyset(sigset_t* p); // обнуляем маску сигналов по указателю p
int sigaddset(sigset_t* p, int sig); // добавляем в маску сигналов p сигнал sig

int sigprocmask(int mode, sigset_t* p, sigset_t* old); 

// 1. возвращает в old предыдущую маску
// 2. mode:
// 	SIG_BLOCK - добавит p к маске блокированных сигналов
// 	SIG_UNBLOCK

int sigsuspend(sigset_t* empty); // ждёт сигнал, который НЕ внесён в маску сигналов p
```


Пример: 
Задан счётчик, стартовое значение счётчика = 0. Создаются 2 процесса, один принимает `int`-числа и в соответствии с чётностью значения передаёт второму процессу сигналы `SIGUSR1` и `SIGUSR2`

Обработка сигналов меняет значение счётчика:
SIGUSR1 - +5
SIGUSR2 - -4

При получении сигнала процесс должен выводить имя сигнала и значение счётчика
При счётчике `< 0` завершить оба процесса и родительский.

`secure_signal.c`
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>


volatile int counter = 0;
pid_t pid1, pid2;
volatile int flag = 1;

void
my_sigusr1(int sig) {
    counter += 5;
	    printf("SIGUSR1 %d\n", counter);
    fflush(stdout);
    return;
}

void
my_sigusr2(int sig) {
    counter -= 4;
    printf("SUGUSR2 %d\n", counter);
    fflush(stdout);

    if (counter < 0) {
        signal(SIGUSR1, SIG_DFL);
        signal(SIGUSR2, SIG_DFL);
        kill(pid2, SIGKILL);
        flag = 0;
    }

    return;
}

int
main(int argc, char** argv)
{
    int fd[2];
    if (pipe(fd) < 0) {
        return 1;
    }

    sigaction(SIGUSR1, &(struct sigaction) { .sa_handler = my_sigusr1, .sa_flags = SA_RESTART}, NULL);
    sigaction(SIGUSR2, &(struct sigaction) { .sa_handler = my_sigusr2, .sa_flags = SA_RESTART}, NULL);

    sigset_t sigmask;
    sigemptyset(&sigmask);
    
    sigaddset(&sigmask, SIGUSR1);
    sigaddset(&sigmask, SIGUSR2);

    sigset_t old;

    sigprocmask(SIG_BLOCK, &sigmask, &old);
    
    if ((pid1 = fork()) < 0) {
        _exit(1);
    } else if (!pid1) {
        read(fd[0], &pid2, sizeof(pid2));
        close(fd[0]);
        close(fd[1]);

        sigset_t empty;
        sigemptyset(&empty);

        while(flag) {
            sigsuspend(&empty);
        }

        return 0;
    }

    if ((pid2 = fork()) < 0) {
        _exit(1);
    } else if (!pid2) {
        int usr_sig;
        while(scanf("%d", &usr_sig) == 1) {
            if (usr_sig & 1) {
                kill(pid1, SIGUSR1);
            } else {
                kill(pid1, SIGUSR2);
            }
        }

        return 0;
    }

    write(fd[1], &pid2, sizeof(pid2));
    close(fd[1]);
    close(fd[0]);

    int status;
    while(wait(&status) != -1);

    return 0;
}
```

```console
stephen@localhost:path/to/somewhere> gcc secure_signal.c -o secure_signal
stephen@localhost:path/to/somewhere> ./secure_signal 
1 
SIGUSR1 5
2
SUGUSR2 1
3
SIGUSR1 6
4
SUGUSR2 2
5
SIGUSR1 7
6
SUGUSR2 3
7
SIGUSR1 8
8
SUGUSR2 4
0
SUGUSR2 0
0
SUGUSR2 -4
stephen@localhost:path/to/somewhere> 
```


# IPC

`InterProcess Communication` - система взаимодействия произвольных процессов в пределах локальной машины. `IPC` основан на идее предоставления взаимодействующим процессам общих, или _разделяемых_, ресурсов ОС, которые можно разделить на три типа:
 + **Массив семафоров** - массив из _семафоров IPC_ (не путать с _Семафорами Дейкстры_: СД - это формальная структура, а IPC-семафор - конкретная реализация семафора в ОС), предназначенных для синхронизации работы процессов.
 + **Разделяемая память** - область памяти, доступная процессам для общей работы
 + **Очередь сообщений** - схема реализации общей очереди для передачи сообщений с возможностью синхронизации работы

Основные библиотеки для работы с `IPC`-объектами:
```c
#include <sys/ipc.h> // Общая библиотека
#include <sys/sem.h> // библиотека семафоров
#include <sys/shm.h> // библиотека разделяемой памяти
#include <sys/msg.h> // библиотека очереди сообщений
```

`IPC`-объекты (как и разделяемые ресурсы ОС, в целом) живут независимо от программы с момента создания до момента их принудительного удаления, либо в течение сеанса работы ОС.


Все IPC-объекты создаются вне процессов и доступны по специальному ключу, сгенерированному по конфигурации какого-то фиксированного файла ФС. С одного файла можно получать один и тот же ключ, что позволяет процессам иметь доступ к разделяемому ресурсу независимо от связей между самими процессами

```c
 key_t ftok(char* fname, char c); // получение ключа
//	fname - имя СУЩЕСТВУЮЩЕГО файла
//	с - сдвиг
```

Чтобы работать с объектом, оба процесса должны получить одинаковые ключи. В ситуациях, когда нам не обязателен какой-то конкретный разделяемый ресурс, и мы можем распространить доступ к нему нескольким процессам (н-р, работаем с родственными, но через IPC), вместо генерации ключа можно будет пользоваться флагом `IPC_PRIVATE`, по которому просто выделяется новый разделяемый сегмент памяти.

## Семафоры

#### Общая теория

Семафор - это целочисленная переменная, над которой определены две _атомарные_ операции P(down) и S(up):
```
Атомарными называются операции, действие которых невозможно отследить в промежуточном состоянии:
в любой момент времени операция или вообще не исполнена, или полностью завершена.

Такой формализм нужен, потому что, вообще говоря, прервать атомарную операцию можно 
(н-р, во время исполнения дёрнуть курсором - движение мыши будет засечено и прерывание с информацией об этом в систему придёт), 
просто само промежуточное состояние операции поймать не получится
```

 + **_P (down)_** - уменьшает значение семафора на 1. Если при этом значение семафора может стать `< 0`, процесс блокируется, а операция считается незавершённой;
 + **_V (up)_** - увеличивает значение семафора на 1. Если при этом по этомусемаформу существует заблокированный процесс, он разблокировывается и завершает операцию **_P_** (`block0` - `unblock1` - `unblock0`)

Семафор не обязательно является бинарным (строго бинарным является формализм Семафора Дейкстры), а может достигать любого положительного значения. Также и при выполнении операций **_P_**, **_S_** изменение может вестись на любое положительное значение (изменение на 1 - тоже обязательный формализм Дейкстры)

#### IPC-реализация

Для использования массива семафоров (1 семафор - это тоже массив, как ни странно) создаём объект

```c
int semget(key_t key, int n, int fl);
// key - ключ из ftok или IPC_PRIVATE
// n - количество элементов в массиве семафоров
```

```
fl:
	IPC_CREAT | 0666 - Один процесс будет создавать IPC-объект, другие подключаться к нему (если у всех это написано)
	IPC_EXCL - Если добавить этот флаг, то один процесс создаст IPC-объект, а другие получат -1(тк они не создают уже созданный). Тогда ещё раз ими подключаемся через semget с флагом 0
```

Для управления массивом используем команду управления `semctl`

```c
int semctl(int id, int semnum, int cmd, union semun arg);
```

```
	semnum - номер семафора, над которым хотим провести операцию (0, если над всеми сразу)

	cmd: - управляющая команда
		SETVAL - установить значение семафора
		GETVAL - текущее значение этого семафора
		SETALL - установить значения массива из arg
		GETALL - загрузить в arg весь массив
		IPC_RMID - удалить весь массив семафоров (удаление IPC-объекта)
		IPC_STAT - получить доступ к системным полям 

	arg: - информационный union-буфер, описывающий разные типы данных 
		int val - значение для единичного семафора
		ushort *array - для получения/установки значений массива семафоров
		struct semid_ds* buf - для описания системных полей
```

Команда управления **неатомарна**; для непосредственной работы **_P_** и  **_S_** используются спец.команды, управлением мы только задаём начальные значения значения и собираем данные по массиву семафором

Для работы с семафорами используется специальная структура `struct sembuf`, над которой оперирует команда `semop`

```c
int semop(int id, struct sembuf* buf, int n)
// id - идентификатор объекта из semget
// buf - Указатель на массив структур размера n (n >= 1)

struct sembuf:
	short sem_num; // номер семафора
	short sem_op; // Операция
	short sem_flg; // Флаги

//  sem_op:
//	    `> 0` - увеличивает значение семафора
//	    `< 0` - пытается уменьшить (блокируется до возможности опустить или пока не удалят семафор)
//	    `= 0` - сравнивает с нулём. Если семафор равен нулю, то успешно. Иначе процесс блокируется, пока нам не вернётся ноль

//  sem_flg:
//	    0 - Тогда будет блокировка
//	    IPC_NOWAIT - Немедленный выход из функции
//	    SEM_UNDO -  Если какой-то процесс будет прерван, а от него зависит зависание других, то отблокирует их (по сути, то же, что и ноль)
```

Пример реализации:
```c
struct sembuf p = {0, -1, 0};
semop(id, &p, 1);

struct sembuf v = {0, 1, 0};
semop(id, &v, 1);
```

Пример: `semping-sempong` **В аргументах командной строки подаётся количество процессов и количество пингов. Необходимо, используя механизм семафоров, по кругу процессами пропинговать указанное число раз, после чего корректно завершиться.**

`sem.c`
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int
main(int argc, char** argv)
{
    if (argc < 3) {
        return -100;
    }

    char* p;
    unsigned nproc = strtol(argv[1], &p, 10);
    unsigned maxval = strtol(argv[2], &p, 10);
 

    pid_t pid;
    unsigned son_num, val = 0;
    int sem = semget(IPC_PRIVATE, nproc, IPC_CREAT | 0666);

    int fd[2];

    if (pipe(fd) < 0) {
        return -1;
    }

    for (int i = 0; i < nproc; i++) {
        son_num = i;

        if ((pid = fork()) < 0) {
            return i + 1;
        } else if(!pid) {
            struct sembuf p = {son_num, -1, 0};
            struct sembuf v = {(son_num + 1) % nproc, 1, 0};
            
            printf("Hello from %u\n", son_num + 1);
            fflush(stdout);

            while (semop(sem, &p, 1) >= 0) {
                if (read(fd[0], &val, sizeof(val)) != sizeof(val)) {
                    return son_num + 1;
                }

                printf("%u ping with %u \n", son_num + 1, val);
                fflush(stdout); // всегда пишем после printf для очистки буфера вывода от мусора

                val++;
                write(fd[1], &val, sizeof(val));
                
                if (val == maxval) {
                    printf("PONG\n");
                    fflush(stdout);
                    break;
                }

                semop(sem, &v, 1);
            }

            printf("Bye from %u\n", son_num + 1);
            fflush(stdout);

            semctl(sem, 0, IPC_RMID, 0);
            close(fd[0]);
            close(fd[1]);
            _exit(0);
        }
    }

    write(fd[1], &val, sizeof(val));
    struct sembuf start = {0, 1, 0};
    semop(sem, &start, 1);

    while(wait(NULL) > 0);

    return 0;
}
```

```console
stephen@localhost:path/to/somewhere> gcc sem.c -o sem
stephen@localhost:path/to/somewhere> ./sem 10 15
Hello from 1
Hello from 2
Hello from 3
Hello from 4
Hello from 5
Hello from 6
Hello from 7
Hello from 8
1 ping with 0 
2 ping with 1 
Hello from 9
Hello from 10
3 ping with 2 
4 ping with 3 
5 ping with 4 
6 ping with 5 
7 ping with 6 
8 ping with 7 
9 ping with 8 
10 ping with 9 
1 ping with 10 
2 ping with 11 
3 ping with 12 
4 ping with 13 
5 ping with 14 
PONG
Bye from 5
Bye from 1
Bye from 2
Bye from 3
Bye from 6
Bye from 8
Bye from 7
Bye from 9
Bye from 10
Bye from 4
stephen@localhost:path/to/somewhere> 
```

_**TODO**_: преобразовать программу, чтобы вывод был совсем последовательный (механизмами синхронизации)


## Разделяемая память

Разделяемая память - область памяти, доступная неродственным процессам по ключу. Работа с ней ведётся, как с обычной динамической памятью.

```c
int shmget(key_t key, size_t size, int fl); // создание разделяемой памяти в ядре
```

```
fl:
	IPC_CREAT | 0666 - Один процесс будет создавать IPC-объект, другие подключаться к нему (если у всех это написано)
	IPC_EXCL - Если добавить этот флаг, то один процесс создаст IPC-объект, а другие получат -1(тк они не создают уже созданный). Тогда ещё раз ими подключаемся через semget с флагом 0
```

Для доступа к памяти настраиваем на неё указатель
```c
void* shmat(int id, void* addres, int flg)
// id - идентификатор объекта из shmget
//	addres - всегда пишем NULL - место, откуда подключается разделяемая память

//	flg:
//		0 - Открыта для всех на чтение и запись
//		SHM_RDONLY - только на чтение
```

```c
char* p = shmat(...); // работает, как указатель на динамическую память
shmdt(p); // Освобождение памяти

shmctl(id, IPC_RMID, 0); // удаление памяти (Верно для всех IPC-объектов: пока все не отключатся, IPC-объект не удалится)
```

Пример: **Создать два сыновьих процесса, синхронизировать их с помощью семафоров над одной разделяемой паматью. Одним процессом считывать строки с входного потока в память, другим - оттуда выводить строки на экран**

`shm.c`
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>

int
main(int argc, char** argv)
{
    int sem = semget(IPC_PRIVATE, 2, IPC_CREAT | 0666);
    int shm = shmget(IPC_PRIVATE, 256, IPC_CREAT | 0666);


    pid_t pid1, pid2;

    if ((pid1 = fork()) < 0) {
        return -1;
    } else if (!pid1) {
        char* shm_writer = shmat(shm, NULL, 0);

        struct sembuf v1 = {0, 1, 0};
        struct sembuf p2 = {1, -1, 0};

        while (fgets(shm_writer, 256, stdin) != NULL) {
            semop(sem, &v1, 1);
            semop(sem, &p2, 1);
        }

        shmdt(shm_writer);
        semctl(sem, IPC_RMID, 0);
        shmctl(shm, IPC_RMID, 0);
    }

    if ((pid2 = fork()) < 0) {
        return -2;
    } else if (!pid2) {
        char* shm_reader = shmat(shm, NULL, SHM_RDONLY);

        struct sembuf p1 = {0, -1, 0};
        struct sembuf v2 = {1, 1, 0};

        while (semop(sem, &p1, 1) >= 0) {
            printf("%s\n", shm_reader);
            fflush(stdout);
            semop(sem, &v2, 1);
        }

        shmdt(shm_reader);
    }

    while(wait(NULL) > 0);

    return 0;
}
```

```console
stephen@localhost:path/to/somewhere> gcc shm.c -o shm
stephen@localhost:path/to/somewhere> ./shm
Hello, guys
Hello, guys

qwerty
qwerty

stephen@localhost:path/to/somewhere> 
```
## Очередь сообщений

Очередь сообщений - Объект, представляющий из себя прокаченную версию канала `pipe`.

Особенности очереди сообщений:
1. Данные приходят и уходят не потоками байт, отчего в общей куче могут быть записаны и прочитаны по-разному, а фиксированными "письмами"
2. Каждое "письмо" содержит свой номер - тип сообщения - по которому можно выделять подочереди и работать с ними

Структура, описывающая письмо, достаточно свободно задаётся. она состоит из 2х полей - `long mtype`, описывающего тип сообщения, и `<any_type> mval`, описывающего передающиеся данные: 
```c
struct Mymsgbuf
{
	long mtype;
	long long mval[2];
}

// mtype - переменная типа сообщения
// mval - переменная\массив данных
```

Создание `IPC`-объекта
```c
int msgget(key_t key, int fl);
```

Отправка сообщения
```c
int msgsnd(int id, void* buf, size_t size, int fl);
// buf - структура, описывающая "письмо".

Размер сообщения считается, как <размер всей структуры> - <размер переменной типа>, так как возможно выравнивание
	size -> sizeof(struct) - sizeof(long)

fl:
	0 - блокировка процесса в ожидании при невозможности отправки в очередь
	IPC_NOWAIT - сразу выдат -1 при ошибке
```

Приём сообщения
```c
int msgrcv(int id, void* buf, size_t size, long type, int fl);

type:
	0 - первое сообщение из очереди(поэтому с типом 0 сообщение создавать нельзя)
	`> 0` - первое с таким типом
	`< 0` - первое с минимальным из типов, меньших или равных абсолютного значения типа

fl:
	IPC_NOWAIT
	MSG_EXCEPT - используется с type > 0, из очереди будет взято первое сообщение с отличным от заданного типом
```

Управление очередью:
```c
int msgctl(int id, int cmd, struct msgid_ds* buf);

cmd:
	IPC_RMID
	IPC_STAT
```

Пример: **В аргументах командной строки задаётся шаг. Необходимо создать 10 сыновьих процессов, каждый из которых напишет в очередь свой PID, а затем прочитает и выведет на экран PID процесса, цеиклически отстоящего от него на заданное число шагов.**

`msg.c`
```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/msg.h>

enum
{
    N_PROC = 10
};

struct msg_buf {
    long mtype;
    long mval;
};

int
main(int argc, char** argv)
{
    if (argc < 2) {
        return 1;
    }

    char* p;
    unsigned step = strtol(argv[1], &p, 10);
 

    pid_t pid;
    unsigned son_num, val = 0;

    int msg = msgget(IPC_PRIVATE, IPC_CREAT | 0666);

    for (int i = 0; i < N_PROC; i++) {
        son_num = i;

        if ((pid = fork()) < 0) {
            return i + 1;
        } else if(!pid) {
            printf("%u -> %ld\n", son_num + 1, getpid());
            fflush(stdout);

            struct msg_buf in_buf = {son_num + 1, getpid()}, out_buf;
            msgsnd(msg, &in_buf, sizeof(in_buf) - sizeof(in_buf.mtype), 0);
            msgrcv(msg, &out_buf, sizeof(out_buf) - sizeof(out_buf.mtype), (son_num + step) % N_PROC + 1, 0);

            printf("%u + %u -> %ld\n", son_num + 1, step, out_buf.mval);
            fflush(stdout);

            _exit(0);
        }
    }

    while(wait(NULL) > 0);
    msgctl(msg, IPC_RMID, 0);

    return 0;
}
```

```console
stephen@localhost:path/to/somewhere> gcc msg.c -o msg
stephen@localhost:path/to/somewhere> ./msg 0
1 -> 168880
2 -> 168881
1 + 0 -> 168880
2 + 0 -> 168881
3 -> 168882
5 -> 168884
5 + 0 -> 168884
3 + 0 -> 168882
4 -> 168883
4 + 0 -> 168883
6 -> 168885
6 + 0 -> 168885
7 -> 168886
7 + 0 -> 168886
8 -> 168887
8 + 0 -> 168887
9 -> 168888
9 + 0 -> 168888
10 -> 168889
10 + 0 -> 168889
stephen@localhost:path/to/somewhere> ./msg 7
2 -> 168896
1 -> 168895
5 -> 168899
5 + 7 -> 168896
3 -> 168897
4 -> 168898
4 + 7 -> 168895
6 -> 168900
7 -> 168901
6 + 7 -> 168897
7 + 7 -> 168898
9 -> 168903
9 + 7 -> 168900
2 + 7 -> 168903
8 -> 168902
8 + 7 -> 168899
1 + 7 -> 168902
10 -> 168904
10 + 7 -> 168901
3 + 7 -> 168904
stephen@localhost:path/to/somewhere> 
```