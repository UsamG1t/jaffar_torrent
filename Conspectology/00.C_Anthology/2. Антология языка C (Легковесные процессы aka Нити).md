Этот раздел является логическим продолжением [раздела про процессы](<1. Антология языка C (Многопроцессное программирование).md>), только на этот раз мы будем рассматривать не полноценные процессы, а так называемые *Нити* (pthreads).

# Общая информация о нитях

Легковесные процессы (далее нити) создаются и используются в рамках одного процесса. Т.е. вне этого процесса созданные нити будут не видны и взаимодействовать с ними невозможно. Также стоит помнить, что у любого процесса **всегда** есть как минимум одна нить, в которой начинает выполняться процесс.

Все нити внутри одного процесса разделяют между собой:
- Глобальные переменные
- Контекст процесса (PID, PPID, сигналы и т.д.)

Однако у каждой нити получается свои:
- Стек
- Регистры процессора (включая счётчик команд)

| **Характеристика**  | **Процесс**                                                   | **Нить**                                                    |
| ------------------- | ------------------------------------------------------------- | ----------------------------------------------------------- |
| Пространство памяти | Отдельное                                                     | Совместное                                                  |
| Создание            | Ресурсоёмкое                                                  | Менее ресурсоёмкое                                          |
| Коммуникация        | Требует использования средств межпроцессорного взаимодействия | Через локальную память процесса                             |
| Изоляция            | Высокая (ошибка в одном процессе не влияет на другой)         | Низкая (ошибка в одной нити может повлиять на весь процесс) |
# Создание нитей

Для работы с нитями используется библиотека `pthread`, подключение которой осуществляется через соответствующий хедер-файл (#include pthread.h).

Для создания нити используется функция `pthread_create`. Общий её прототип: 
`int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void* (*start)(void *), void *arg)` 
Она принимает следующие параметры:

1. Указатель на переменную типа `pthread_t`, где будет сохранен идентификатор новой нити.
2. Указатель на атрибуты нити (можно передать `NULL` для использования значений по умолчанию).
3. Указатель на функцию, которую будет выполнять нить.
4. Аргумент, передаваемый в функцию нити.

Пример:
``` C
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

// Функция, выполняемая нитью
void* thread_function(void* arg) {
    int *num = (int*) arg;
    printf("Нить получила число: %d\n", *num);
    pthread_exit(NULL);
}

int main() {
    pthread_t thread;
    int number = 42;
    int result;

    // Создание нити
    result = pthread_create(&thread, NULL, thread_function, &number);
    if (result != 0) {
        printf(stderr, "Ошибка создания нити\n");
        exit(EXIT_FAILURE);
    }

    // Ожидание завершения нити
    pthread_join(thread, NULL);
    printf("Нить завершена\n");
    return 0;
}
```


Как вы видите, здесь добавлена проверка на то, что значение, возвращённое `pthread_create()` $!=0$. Это требуется, так как 0 будет возвращён **только в случае успешного создания**, иначе будет возвращён код ошибки

# Завершение нитей

Нить может завершиться самостоятельно, вызвав `pthread_exit`, или завершиться при завершении функции, переданной в `pthread_create`. 

Также главный поток может ожидать завершения нити с помощью `pthread_join` (аналог `wait()` для процессов).

```C
int pthread_join(pthread_t thread, void **retval);
	// Ожидает завершения указанной нити и принимает возвращённое нитью значение
```

Основные свойства `pthread_join()`:
- **Синхронизация**: Гарантирует, что основной поток дождётся завершения дочерней нити перед продолжением работы или завершением программы.
- **Освобождение ресурсов**: После вызова `pthread_join` системные ресурсы, связанные с завершившейся нитью, освобождаются.
	- Это позволяет избежать утечек ресурсов, связанных с завершившимися нитями
- **Получение результатов**: Позволяет получить возвращаемое значение из завершившейся нити.


Пример того, как может происходить завершение нити:

```C
#include <pthread.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <unistd.h>  
  
void *thread_function2(void *arg) {  
    int method = *(int *) arg;  
  
    if (method == 0) {  
        printf("Нить %lu: Выполнение вложенной функции потока с возвратом через return.\n", pthread_self());  
        sleep(1);  
        return NULL;  
    }  
    else{  
        printf("Нить %lu: Выполнение вложенной функции потока с возвратом через pthread_exit.\n", pthread_self());  
        sleep(1);  
        pthread_exit(NULL);  // Демонстрация того, что такой вызов завершит всю нить целиком
    }  
}  
  
  
void *thread_function1(void *arg) {  
    int method = *(int *) arg;  
  
    if (method == 0) {  
        printf("Нить %lu: Выполнение главной функции потока с возвратом через return.\n", pthread_self());   
        thread_function2(arg);  
        printf("Нить %lu: Завершена возвратом из главной функции потока через return.\n", pthread_self());  
        return NULL; // Завершение нити через возврат
    } else if (method == 1) {  
        printf("Нить %lu: Выполнение главной функции потока с возвратом через pthread_exit.\n", pthread_self());    
        thread_function2(arg);  
        printf("Нить %lu: Главная функция потока завершена вызовом pthread_exit.\n", pthread_self());  
        pthread_exit(NULL); // Завершение нити через pthread_exit  
    } else {  
        printf("Нить %lu: Неизвестный метод завершения.\n", pthread_self());  
        int error = 1;  
        pthread_exit((void *) &error);  
    }  
}  
  
int main(void) {  
    pthread_t tid[2];  
    int methods[2] = {0, 1};  
    int result;  
  
    // Создание нитей и запись их идентификаторов в массив  
    for (int i = 0; i < 2; i++) {  
        result = pthread_create(&tid[i], NULL, thread_function1, &methods[i]);  
        if (result != 0) {  
            fprintf(stderr, "Ошибка создания первой нити\n");  
            exit(EXIT_FAILURE);  
        }  
    }  
  
    // Ожидание завершения нитей  
    for (int i = 0; i < 2; i++) {  
        pthread_join(tid[i], NULL);  
        printf("Главный поток: нить номер %d завершена.\n", i);  
    }  
  
    printf("Главный поток: Завершение программы.\n");  
    return 0;  
}
```

Как мы видим на примере, если мы вызываем `pthread_exit` из вложенной функции, то у нас завершается вся нить целиком, в то время как при вызове `return` завершается только вложенная функция.

Однако что произойдёт, если выполнить такой завершение основной нити (выполнить завершение из `main()`)?  Рассмотрим на примере:

```C
#include <pthread.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <unistd.h>  
  
// Функция, выполняемая дополнительной нитью  
void *worker_thread(void *arg) {  
    int id = *(int *) arg;  
    for (int i = 1; i <= 5; ++i) {  
        printf("Нить %d: Шаг %d\n", id, i);  
        sleep(1); // Симуляция работы  
    }  
    printf("Нить %d: Завершена.\n", id);  
    return NULL;  
}  
  
int main(void) {  
    pthread_t thread;  
    int thread_id = 1;  
  
    int mode;  
    if (!scanf("%d", &mode)) {  
        fprintf(stderr, "Неизвестный режим работы\n");  
        exit(1);  
    }  
  
    // Создание дополнительной нити, на примере работы которой мы увидем различия  
    if (pthread_create(&thread, NULL, worker_thread, &thread_id) != 0) {  
        perror("pthread_create");  
        exit(EXIT_FAILURE);  
    }  
  
    if (mode == 0) {  
        printf("Главный поток: Завершение с помощью return.\n");  
        return 0; // Завершение main через return  
    } else{  
        printf("Главный поток: Завершение с помощью pthread_exit.\n");  
        pthread_exit(NULL); // Завершение main через pthread_exit  
    }
}
```

Допустим, мы введём $1$, как отработает программа?

```bash
aleks_mozz@MyLinux:~/CLionProjects/OS_prac/Threads$ ./a.out 
1
Главный поток: Завершение с помощью pthread_exit.
Нить 1: Шаг 1
Нить 1: Шаг 2
Нить 1: Шаг 3
Нить 1: Шаг 4
Нить 1: Шаг 5
Нить 1: Завершена.
```

Мы вызвали `pthread_exit()` в основной нити до завершения второй нити, однако вторая нить полноценно отработала.

Теперь попробуем запустить программу и передать ей $0$:

```bash
aleks_mozz@MyLinux:~/CLionProjects/OS_prac/Threads$ ./a.out 
0
Главный поток: Завершение с помощью return.
Нить 1: Шаг 1
```

Выполнив `return` из основной нити процесс завершился полностью, не дожидаясь завершения нити.

То же самое произойдёт, если вызвать `exit()` из любой нити.


Суммирую приведённую выше информацию, выделим следующий особенности завершения нитей:
1. Нить может завершиться вызовом `pthread_exit()` из любой точки нити
2. Выход из главной функции нити вызовом `return()`
3. Принудительное завершение нити из другой нити с помощью `pthread_cancel(pthread_t tid)` 
	- отдельно на примере данный пункт не рассматривался, однако он работает очень похоже на `kill(PID, SIGINT)`
	- вызывает завершение указанной нити
	- указанная нить можете перехватить эту команду и обработать её 

# Отсоединение нитей

В многопоточном программировании на языке C существует два состояния нитей: **присоединяемые (joinable)** и **отсоединённые (detached)**.

## Что такое отсоединённая нить?

**Отсоединённая нить** — это нить, которая автоматически освобождает все свои ресурсы (например, память стека) после завершения выполнения, без необходимости явного присоединения с помощью функции `pthread_join` к основной нити. В отличие от **присоединяемых нитей**, отсоединённые нити не могут быть присоединены, и их завершение происходит независимо от других нитей.

Рассмотрим основные отличия присоединяемых от отсоединённых нитей:

| **Характеристика**        | **Присоединяемая нить (Joinable)**                         | **Отсоединённая нить (Detached)**                                                           |
| ------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| Управление ресурсами      | Требуется вызов `pthread_join()` для освобождения ресурсов | Автоматически освобождаются после завершения                                                |
| Возможность присоединения | Да                                                         | Нет                                                                                         |
| Создание                  | Все нити по умолчанию создаются присоединяемыми            | Требуется явное указание флага или отсоединение после создания с помощью `pthread_detach()` |


## Отсоединение нити

Получить отсоединённую нить внутри процесса нужно проделать одно из следующих действий:
1. Отсоединение уже созданной нити с помощью `pthread_detach`
2. Установка атрибута нити как отсоединённого при создании с помощью `pthread_attr_t`

Далее мы рассмотрим только первый пункт, так как подробно погружаться во все возможные атрибуты, устанавливаемые при создании, не имеет смысла.

### Отсоединение существующей нити

После создания нити можно отсоединить её, вызвав функцию `pthread_detach`, передав ей идентификатор нити.

```C
int pthread_detach(pthread_t thread);
```

Пример работы отсоединённых нитей:
```C
#include <pthread.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <unistd.h>  
  
// Функция, выполняемая нитью  
void *thread_function(void *arg) {  
    int *num = (int *) arg;  
    printf("Отсоединённая нить получила число: %d\n", *num);  
    sleep(2); // Симуляция работы  
    printf("Отсоединённая нить завершена\n");  
    pthread_exit(NULL);  
}  
  
int main(void) {  
    pthread_t thread;  
    int number = 42;  
  
    // Создание нити  
    if (pthread_create(&thread, NULL, thread_function, &number) != 0) {  
        fprintf(stderr, "Ошибка создания нити\n");  
        exit(EXIT_FAILURE);  
    }  
  
    // Отсоединение нити  
    if (pthread_detach(thread) != 0) {  
        fprintf(stderr, "Ошибка отсоединения нити\n");  
        exit(EXIT_FAILURE);  
    }  
  
    printf("Главный поток продолжает работу без ожидания нити\n");  
    // Здесь можно выполнить другую работу  
    sleep(3); // Даем отсоединённой нити время завершиться  
    printf("Главный поток завершен\n");  
    return 0;  
}
```

### Поведение отсоединённых нитей

- Автоматическое освобождение ресурсов
	- Отсоединённые нити автоматически освобождают свои ресурсы после завершения выполнения. Это означает, не обязаntkmyj вызывать `pthread_join` для таких нитей.

- Отсутствие возможности присоединения
	- Отсоединённая нить не может быть присоединена с помощью `pthread_join`. Попытка вызвать `pthread_join` для отсоединённой нити приведёт к неопределённому поведению или ошибке.
# Идентификаторы нитей

Как мы видели, идентификатор нити имеет специальный тип `pthread_t`, который далеко не всегда является типом данных, который можно привести к `int` или аналогичным.

К примеру, он может быть реализован следующим образом:
- В Linux 3.2.0 используется тип long int
- Во FreeBSD 8.0 и Mac OS X 10.6.8 в качестве типа pthread_t используют указатель на структуру pthread

Для 100% корректной обработки идентификаторов нитей в любых ОС необходимо использовать специальные функции.

```C
int pthread_equal(pthread_t tid1, pthread_t tid2)
	//Проверяет равенство двух TID-ов
	//0 - если не равны и ненулевое значение иначе
```


# Синхронизация работы нитей

В многопоточном программировании **синхронизация** является ключевым аспектом для обеспечения корректного и безопасного взаимодействия между нитями. Мьютексы позволяют управлять доступом к разделяемым ресурсам, предотвращая **гонки процессов** и обеспечивая целостность данных.

## Определение мьютекса

**Мьютекс** (от **mutual exclusion** — взаимное исключение) — это объект синхронизации, который обеспечивает **эксклюзивный доступ** к разделяемому ресурсу между несколькими нитями. В любой момент времени только одна нить может владеть мьютексом, что предотвращает одновременный доступ к критической секции кода или разделяемым данным.

Если рассматривать их с практической точки зрения, то **мьютекс** — переменная специального типа `pthread_mutex_t`, определяемого в заголовочном файле. Он может быть определён как статическая, автоматическая или динамическая переменная

## Инициализация мьютекса

Перед использованием мьютекса его необходимо инициализировать. Это можно сделать двумя способами:

- **Статическая инициализация** с помощью макроса `PTHREAD_MUTEX_INITIALIZER`.
- **Динамическая инициализация** с помощью функций `pthread_mutex_init` и `pthread_mutex_destroy`.

Пример статической инициализации:

```C
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
```

Пример динамической инициализации:

```C
int pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t *attr)

	//mutex — указательна переменную типа мьютекс
	//attr - атрибуты (будем использовать по умолчанию NULL)
```

Если мьютекс был создан динамически, то после окончания использования, его необходимо удалить.

```C
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

## Блокировка мьютексов

В общем случае, использовать мьютексы необходимо, когда нужно организовать доступ к разделяемым ресурсам (те ресурсы, к которым едино моментно должна иметь доступ лишь одна нить)

### Основные понятия

- **Блокировка мьютекса** — это процесс захвата мьютекса нитью для доступа к защищаемому ресурсу. Когда нить блокирует мьютекс, она становится **владельцем** этого мьютекса, и другие нити, пытающиеся заблокировать тот же мьютекс, будут остановлены и ожидать его освобождения.

- **Разблокировка мьютекса** — это процесс освобождения захваченного мьютекса. После разблокировки мьютекса другая ожидающая нить может успешно захватить его и продолжить выполнение критической секции.

- **Критическая секция** — это часть кода, которая обращается к разделяемым ресурсам и должна быть защищена мьютексом для предотвращения одновременного доступа нескольких нитей. 
	- К примеру, запись в файл. Если две нити одновременно будут пытаться писать в файл, то вместо внятного текста мы получим мешанину либо вообще ошибку.
### Виды блокировок

#### `pthread_mutex_lock`

Функция `pthread_mutex_lock` блокирует мьютекс. Если мьютекс уже заблокирован другой нитью, текущая нить будет ждать, пока мьютекс не станет доступным.

```C
int pthread_mutex_lock(pthread_mutex_t *mutex);
	// Блокирует указанный мьютекс. Если мьютекс уже захвачен другой нитью, текущая нить будет ожидать его освобождения.
	//Возвращаемое значение: 0 при успешном выполнении, код ошибки в случае неудачи.
```

#### `pthread_mutex_trylock`

Пытается заблокировать мьютекс без ожидания. Если мьютекс доступен, он блокируется, и функция возвращает `0`. Если мьютекс уже захвачен, функция возвращает ошибку `EBUSY`.

```C
int pthread_mutex_trylock(pthread_mutex_t *mutex);
```

### Разблокировка мьютекса `pthread_mutex_unlock`

Разблокирует указанный мьютекс. Только владелец мьютекса (нить, которая его захватила) может успешно разблокировать мьютекс.

```C
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

## Взаимные блокировки (Deadlocks)

В случае неаккуратного использования мьютексов, может возникнуть взаимная блокировка — ситуация когда две или более нити ждут освобождения ресурсов, удерживаемых друг другом, создавая циклическую зависимость.

Приведём пример взаимной блокировки:

```C
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

pthread_mutex_t mutex1;
pthread_mutex_t mutex2;

void* thread1_func(void* arg) {
    pthread_mutex_lock(&mutex1);
    printf("Нить 1: Захватила mutex1\n");
    sleep(1);
    pthread_mutex_lock(&mutex2);
    printf("Нить 1: Захватила mutex2\n");

    // Освобождение мьютексов
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
    pthread_exit(NULL);
}

void* thread2_func(void* arg) {
    pthread_mutex_lock(&mutex2);
    printf("Нить 2: Захватила mutex2\n");
    sleep(1);
    pthread_mutex_lock(&mutex1);
    printf("Нить 2: Захватила mutex1\n");

    // Освобождение мьютексов
    pthread_mutex_unlock(&mutex1);
    pthread_mutex_unlock(&mutex2);
    pthread_exit(NULL);
}

int main() {
    pthread_t thread1, thread2;
    int ret;

    // Инициализация мьютексов
    pthread_mutex_init(&mutex1, NULL);
    pthread_mutex_init(&mutex2, NULL);

    // Создание нитей
    pthread_create(&thread1, NULL, thread1_func, NULL);
    pthread_create(&thread2, NULL, thread2_func, NULL);

    // Ожидание завершения нитей
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    // Разрушение мьютексов
    pthread_mutex_destroy(&mutex1);
    pthread_mutex_destroy(&mutex2);

    return 0;
}

```

## Гонки нитей

**Гонки нитей** — это ситуация, когда результат выполнения программы зависит от неконтролируемого порядка выполнения операций несколькими нитями. 

Последствия гонок нитей

- **Непредсказуемое поведение:** Программа может вести себя по-разному при разных запусках или условиях.
- **Трудности в отладке:** Гонки нитей часто проявляются лишь при определённых условиях, что делает их обнаружение и исправление сложными.

### Задача на порядок выполнения нитей

В курсе ОС вам предстоит решать задачи, где необходимо определить всевозможные выводы программы. Рассмотрим одну из таких.

```C
#include <stdio.h>  
#include <pthread.h>  
#include <unistd.h>  
  
int counter = 0;  
pthread_mutex_t mut_id1 = PTHREAD_MUTEX_INITIALIZER;  
  
void *func(void *pid) {  
    pthread_mutex_lock(&mut_id1);  
    printf("%d", counter++);  
    printf("%s", (char *) pid);  
    pthread_mutex_unlock(&mut_id1);  
    printf("%s", (char *) pid);  
    pthread_exit(NULL);  
}  
  
int main(void) {  
    char *str1 = "a", *str2 = "b";  
    pthread_t th_id1, th_id2;  
    pthread_create(&th_id1, NULL, func, str1);  
    pthread_mutex_lock(&mut_id1);  
    pthread_create(&th_id2, NULL, func, str2);  
    printf("%d", ++counter);  
    pthread_mutex_unlock(&mut_id1);  
    pthread_join(th_id1, NULL);  
    pthread_join(th_id2, NULL);  
    return 0;  
}
```

Возможные варианты вывода:
```
0aa22bb
0a2a2bb
0a22abb
0a22bab
0a22bba
11aa2bb
11a2abb
11a2bab
11a2bba
11bb2aa
11b2baa
11b2aba
11b2aab
```


#  Пример работы с нитями (читатели и писатели)

Используя нити можно написать практически любую программу, написанную с использованием полновесных процессов. Рассмотрим это на примере задачи "Читателей и писателей"

```C
#include <stdio.h>  
#include <time.h>  
#include <stdlib.h>  
#include <pthread.h>  
#include <unistd.h>  
  
time_t tmstart;  
//разделяемая переменная - число одновременно работающих читателей  
int rc = 0;  
//определение и инициализация мьютексов, состояние "открыт"  
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;  
pthread_mutex_t db = PTHREAD_MUTEX_INITIALIZER;  
  
//эмуляция работы нити – пауза в течение nsec секунд  
void do_some_work(int nsec) {  
    sleep(nsec);  
}  
  
void *reader(void *arg) {  
    int flag = 0;  
    pthread_mutex_lock(&mutex);  
    rc++;  
    if (rc == 1) { //флаг – данная нить захватила мьютекс  
        flag = 1;  
        pthread_mutex_lock(&db);  
    }  
    pthread_mutex_unlock(&mutex);  
    do_some_work(5);  
  
    pthread_mutex_lock(&mutex);  
    rc--;  
  
    while (flag) {  
        //цикл ожидания работает только в нити (первом читателе), которая захватила мьютекс db  
        if (rc == 0) {  
            //освобождение мьютекса db захватившей его нитью   
pthread_mutex_unlock(&db);  
            flag = 0;  
        } else { // ожидание окончания текущей очереди читателей для корректного (в этой же нити) освобождения db  
  
            //проверка состояния очереди читателей раз в секундe, неблокирующее ожиданиеpthread_mutex_unlock(&mutex);  
            sleep(1);  
            pthread_mutex_lock(&mutex);  
        }  
    }  
    pthread_mutex_unlock(&mutex);  
  
    printf("---Читатель #%lu завершился на %ld секунде\n", 
			    pthread_self(), time(0) - tmstart);  
    return NULL;  
}  
  
  
//реализация нити писателя  
void *writer(void *arg) {  
    pthread_mutex_lock(&db);  
    do_some_work(12);  
    pthread_mutex_unlock(&db);  
    printf("---Писатель #%lu завершился на %ld секунде\n", 
			    pthread_self(), time(0) - tmstart);  
    return NULL;  
}  
  
int main(void) {  
    int nr, nw, bFlag;  
    pthread_t th_id;  
    printf(">>Введите число читателей и писателей:\n");  
    scanf("%u %u", &nr, &nw);  
    tmstart = time(0); //начальная точка отсчёта в секундах  
    bFlag = nr <= 0; //значение 0-порождает читателя, 1-писателя  
    //цикл порождения читателей и писателей чередованием    while (nr > 0 || nw > 0) {  
        pthread_create(&th_id, NULL, bFlag ? writer : reader, NULL);  
        printf("++%s #%lu запущен на %ld секунде\n", 
		        bFlag ? "Писатель" : "Читатель", th_id, time(0) - tmstart);  
        //выбираем тип нити для запуска на следующей итерации чередованием (если не исчерпаны)  
        bFlag = bFlag ^ ((nr--, nr == 0) || (nw--, nw == 0));  
    }  
    for (;;) sleep(5); /*бесконечный цикл ожидания*/  
    return 0;  
}
```