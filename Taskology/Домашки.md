В этом файлике будут аккумулироваться задачи повышенной сложности, похожие на задачник, которые мы будем для вас придумывать, а также к ним будут сюда же дописываться решения и ответы. \
Также сюда будут писаться задачки по проге каких-нибудь реализаций, чтобы мы учились с вами и их безошибочно писать.

---

# Задачи на `IP`

##### Кривые сети

Даны 5 IP-адресов одной сети:
```
234.147.123.67
234.147.105.68
234.147.109.69
234.147.117.70
234.147.113.71
```

Определите максимальный IP-адрес сети, для него IP-адрес маски, а также выпишите в 8-СС все хосты


##### Подсетевой каблучник

Романтик Гогий приехал к друзьям, чтобы поиграть в Монополию. Гогий привёз огромный букет подруге, в квартире которой ребята собрались играть; настолько тяжёлый и настолько хрупкий, что подняться с ним, не повредив, он сможет лишь единожды в квартиру к подруге, второй раз поездку в лифте букет не переживёт. К печали Гогия дом оказался многоэтажный и многоподъездный. Чтобы впечатлить девушку, Гогий решил сделать сюрприз и зайти без предупреждения, но он не знает ни подъезд, ни этаж, ни квартиру. Зато Гогий знает, как настроены сети в доме, и считает, что это ему поможет.

На весь дом выделена сеть $76.111.116.0/22$, она разделяется между 14ю подъездами, а хостами подсети выступают относительные номера квартир в подъезде.
В доме 16 этажей, на каждом этаже гарантировано по 4 квартиры, кроме первого, там две.

Гогий знает, что IP-адрес квартиры подруги (без учёта маски) принадлежит классу А с сетью $114_8$ и хостом $6F7665_{16}$. Помогите Гогию определить подъезд, этаж и номер квартиры подруги при общей нумерации квартир. Помните, что этажи, подъезды и квартиры нумеруются с ***единицы***. 


##### Масочный режим

Администрация факультета ВМК узнала, что с IP-адреса $133.72.28.13$ сети факультета $133.72.0.0/N$ распространяется информация о кори на факультете. Вам, как опытному сетевику на ваш IP-адрес $133.79.255.254$ прислали срочный запрос на удаление пользователся. Требуется `вычислить по IP`, где и кто занимается распространением. \
Факультет поддерживает сеть на пяти этажах - 1ом, 2ом, 5ом, 6ом и 7ом -, на каждом из этажей до 9 маршрутизаторов, делящих этаж на сектора. Каждый сектор покрывает до 20 кабинетов,  в каждом кабинете до 7 портов для подключения устройств.

Опишите все адреса сетей всех маршрутизаторов на пути данных, а также назовите точное нахождение пользователся-спамера в виде `Этаж - Сектор - Кабинет - Порт`. Кстати, а где находится ваш кабинет?


---
Задачи на fork
---

1. Пусть процесс с `PID` `P1` породил два сыновьих процесса с `PID` -ами `P2` и `P3` : \ 

```console
P1
├── P2
└── P3
```

```c
int main(int argc, char **argv) //PID = P1
{
	if (fork() == 0) { //PID = P2
		printf ("%d %d \n", getppid(), getpid());
		exit(0);
	}
	if (fork() == 0) { //PID = P3
		printf ("%d \n", getpid());
		exit(0);
	}
	
	return 0;
}
```

Считаем, что `printf` работает атомарно и без буферизации и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы.

2. Усложняем: Начальный процесс - также `P1`

`Иерархия`
```
P1
├── P2
│   └── P4
└── P3
```

Код:
```c
int main(int argc, char **argv)
{
	if (fork() == 0) {
		printf ("%d %d \n", getppid(), getpid());
	}
	if (fork() == 0) {
		printf ("%d \n", getpid());
		exit(0);
	}
	
	return 0;
}
```

Считаем, что `printf` работает атомарно и без буферизации и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы.

3. Начальный процесс - `P2`

`Иерархия`
```
P1
│
P2
├── P3
│   └── P5
└── P4
```


Код:
```c
int main(int argc, char **argv)
{
	fork();
	printf ("%d %d \n", getppid(), getpid());

	if (fork() == 0) {
		printf ("%d %d \n", getppid(), getpid());
	}

	while(wait(NULL) != -1);
	return 0;
}
```

Считаем, что `printf` работает атомарно и без буферизации и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы.

4. _Задачка на отдохнуть_:

`Иерархия`
```console
A
├── B
└── C
```

`Код`
```c
int main(int argc, char **argv) //PID = P1
{
	if (fork() == 0) {
		printf ("%d %d \n", getppid(), getpid());
		exit(0);
	}
	if (fork() == 0) {
		printf ("%d %d \n", getppid(), getpid());
		exit(0);
	} else {
		printf ("%d \n", getpid());
	}
	
	return 0;
}
```

Считаем, что `printf` работает атомарно и c буферизацией не на стороне процесса и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы.

5. Известна некая иерархия процессов:

```console
A
│
B
├── C
│   └── E
└── D
```

Заданы две программы, каждая запущена для какого-то/каких-то из процессов (возможно, для одного и того же) (Необязательно, чтобы в задании создавались все эти процессы. Просто если создаются, то с `PID`-ами согласно иерархии)

Определить ВСЕ возможные выводы программ при условии корректности всех операций (== вы однозначно можете сказать, что будет выводиться(даже если вариантов несколько, вы точно знаете, что в каждом из них может быть написано)), атомарности команд, отсутствия буферизации и успешности системных вызовов.

В случае большого числа ответов разрешается написать их количество и примерное дерево решений или любое другое описательное пояснение, как данное количество было получено

`Посложнее`
```c
int main(void) { 
    if (!fork()) { 
        printf("%d %d\n", getpid(), getppid());
    }
    fork();
    wait(NULL);
    printf("%d %d\n", getpid(), getppid());
}
```

`Попроще`
```c
int main(void) {
    if (fork()) {
        printf("%d %d\n", getpid(), getppid());    
    } else {
        if (!fork()) {
            printf("%d %d\n", getpid(), getppid());
        }
    }
    wait(NULL);
}
```

6. Пусть процесс с `PID` `X` порождает два сына `Y` и `Z` и внука `W` 
Гарантируется, что первый `fork()` создаёт процесс `Y`

```c
int main(void) { // X
    int status;
    int pid = getpid();
    if (fork() == 0) { // Y
        printf("%d, %d\n", pid, getpid());
        pid = getpid();
    }
    fork();
    printf("%d, %d\n", pid, getpid());
    waitpid(-1, &status, WNOHANG);
    return 0;
}
```

Гарантируются атомарность операций, отсутствие буферизации и успешные системные вызовы. Написать количество возможных вариантов вывода и отдельно для каждого процесса что он выводит \
(`Формат`: $Всего\ N\ выводов;\ процесс\ X\ печатает\ "X\ X\n\ X\ X",\ процесс\ Y\ печатает\ "..."$)