## Задание №1

### Вариант А

В оперативном запоминающем устройстве 64-разрядного компьютера используется контроль целостности данных по чётности. Описать возможную структуру ячейки памяти и ее побитовое содержимое для случая хранения в машинном слове шестнадцатеричного числа `DEADBEEF12345678`$_{16}$

### Вариант B

В оперативном запоминающем устройстве 32-разрядного компьютера используется контроль целостности данных по чётности. Описать возможную структуру ячейки памяти и ее побитовое содержимое для случая хранения в машинном слове шестнадцатеричного числа `37564012743`$_{8}$

### Вариант C

В оперативном запоминающем устройстве 16-разрядного компьютера используется контроль целостности данных по чётности. Описать возможную структуру ячейки памяти и ее побитовое содержимое для случая хранения в машинном слове шестнадцатеричного числа `756453`$_{8}$
## Задание №2

### Вариант А

В системе 32 банка, адрес — 24-битный. Какому банку будет принадлежать адрес `1F 3A7`$_{16}$

### Вариант B

Пусть дано число `321203213`$_4$, являющееся адресом оперативной памяти, расслоённой по 8 банкам. Банку с каким номером принадлежит заданный адрес?
### Вариант C

Видеопамять объёмом 4 Мбайт организована в 16 банков. Для адреса `735264`$_8$ указать номер банка и смещение в нём.
## Задание №3

### Вариант А

Дан 32-разрядный IP-адрес  `23471543210`$_8$ . Определить класс адреса и номер сети (в восьмеричном виде).

### Вариант B

Офисный роутер получил IP-адрес в виде шестнадцатеричного числа `C0A80101`$_{16}$ . Записать адрес в привычном десятичном виде и определить класс.

### Вариант C

Есть IP-адрес 201.34.155.200 и маска 255.255.255.224. Определить
базовый класс сети, адрес сети с маской, вычислить максимальные номера хостов в базовом классе и классе с маской и найти из разницу.

### Вариант D (доп. со звёздочкой)

На факультет приходит жалоба на спам с IP 133.80.45.13. Факультет использует сеть 133.80.0.0/17, каждая кафедра — подсеть /21, каждый сектор в подсети — /24.
 + Определить адрес подсети кафедры, из которой пришёл спам,
 + Определить адрес подсети сектора,
 + Сколько максимум рабочих станций в секторе?
## Задание №4

Дерево процессов (В начале задания указывается, с какого процесса начинается запуск. В случае множества сыновей последовательность создания совпадает с порядком в списке)

```console
A
├── B
│   └── C
└── D
```

Считаем, что printf работает атомарно и без буферизации, и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы.
### Вариант А

```c
int main() {
	if (fork() && fork()) {
		printf("X %d\n", getpid());
	} else {
		printf("Y %d\n", getpid());
	}
	
	return 0;
}
```
### Вариант B

```c
int main() { 
	if (fork() == 0) {
		printf("%d\n", getpid());
		exit(0);
	}
	wait(NULL);

	if (fork() == 0) {
		printf("%d %d \n", getpid(), getppid());
		exit(0);
	}
	return 0;
}
```
### Вариант C

```c
int main(int argc, char **argv)
{
	if (fork() == 0) {
		printf ("%d %d \n", getppid(), getpid());
	}
	if (fork() == 0) {
		printf ("%d \n", getpid());
		exit(0);
	}
	
	return 0;
}
```
## Задание №5

### Вариант А

Пусть дан 32-разрядный компьютер, в котором реализована одноуровневая таблица страниц. Размер страницы 4096 байт. 
+ Сколько бит занимает поле смещения?
 + Сколько страниц в логическом адресном пространстве?
### Вариант B

Пусть дан 32-разрядный компьютер, в котором реализована 2-уровневая таблица страниц. Размер страницы 2048 байт. Размер каждой таблицы 2-ого уровня — 512 записей. Сколько записей содержит «внешняя таблица страниц»?

### Вариант C

Виртуальное адресное пространство процесса — 2 Гбайт, физическая память — 512 Мбайт, память разбита на страницы по  8 Кбайт. Сколько максимум строк может быть в таблице страниц процесса? В инвертированной таблице страниц ОС?
## Задание №6

Что будет выведено на экран? Если возможны несколько вариантов – привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации. Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено. 
### Вариант А

```c
int main() {
  char c = '1';
  int fd[2], fd2[2]; 
  pipe(fd); 
  pipe(fd2); 
  
  if(fork() == 0) { 
    write(fd[1], &c, 1); 
    putchar('2'); 
    read(fd2[0], &c, 1); 
    putchar('3'); 
    exit(0); 
  } 
  
  putchar('4'); 
  read(fd[0], &c, 1); 
  putchar('5'); 
  write(fd2[1], &c, 1); 
  wait(NULL); 
  putchar('6'); 
  return 0; 
}
```
### Вариант B

```c
int main() { 
  char c = 'x'; 
  int fd[2], fd2[2]; 
  pipe(fd); 
  pipe(fd2); 
  
  if(fork() == 0) { 
    read(fd[0], &c, 1); 
    putchar('d'); 
    read(fd2[0], &c, 1); 
    putchar('b'); 
    exit(0); 
  } 

  putchar('a');
  write(fd[1], &c, 1); 
  putchar('c'); 
  write(fd2[1], &c, 1); 
  wait(NULL); 
  putchar('f'); 
  return 0; 
}

```

### Вариант C

```c
int main() {
  int fd[2];
  pipe(fd);
  char x[] = "1234\n";
  if(fork()) {
    write(1, x, 3);
    write(fd[1], x, 2);
  } else {
    write(fd[1], &x[2], 2); 
    read(fd[0], x, 2);
    read(fd[0], x+2, 2); 
  }

  pipe(fd);
  if (fork()) {
    write(fd[1], x+3, 1);
    write(fd[1], x+2, 1);
    write(fd[1], x+1, 1);
    write(fd[1], x, 1);
    while(wait(NULL) != -1);
  } else {
    read(fd[0], x, 1);
    read(fd[0], x+1, 1);
    read(fd[0], x+2, 1);
    read(fd[0], x+3, 1);    
  }

  write(1, x, 5);
  return 0;
}
```

## Задание №7

Что будет выведено на экран в результате работы фрагмента программы? Если возможны несколько вариантов – привести все. Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации. Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено. `msgId` – идентификатор существующей пустой очереди сообщений.
### Вариант А

```c
struct { long type; char data[1]; } msg;
<...> 

msg.type = 1; msg.data[0] = '1'; msgsnd(msgId, &msg, 1, 0); 
msg.type = 2; msg.data[0] = '2'; msgsnd(msgId, &msg, 1, 0); 
msg.type = 2; msg.data[0] = 'a'; msgsnd(msgId, &msg, 1, 0); 
msg.type = 1; msg.data[0] = 'b'; msgsnd(msgId, &msg, 1, 0); 

msgrcv(msgId, &msg, 1, 2, 0); putchar(msg.data[0]); 
msgrcv(msgId, &msg, 1, 0, 0); putchar(msg.data[0]); 
msgrcv(msgId, &msg, 1, 1, 0); putchar(msg.data[0]);
```
### Вариант B

```c
int main() {
  
  struct { long type; char data[1]; } msg;
  msgId = msgget(IPC_PRIVATE, 0);

  msg.type = 3; msg.data[0] = 'H'; msgsnd(msgId, &msg, 1, 0); 
  msg.type = 1; msg.data[0] = 'e'; msgsnd(msgId, &msg, 1, 0); 
  msg.type = 5; msg.data[0] = 'l'; msgsnd(msgId, &msg, 1, IPC_NOWAIT); 
  msg.type = 7; msg.data[0] = 'l'; msgsnd(msgId, &msg, 1, 0); 
  msg.type = 4; msg.data[0] = 'o'; msgsnd(msgId, &msg, 1, 0); 
  msg.type = 8; msg.data[0] = 'D'; msgsnd(msgId, &msg, 1, IPC_NOWAIT); 
  msg.type = 2; msg.data[0] = 'u'; msgsnd(msgId, &msg, 1, 0); 
  msg.type = 1; msg.data[0] = 'd'; msgsnd(msgId, &msg, 1, IPC_NOWAIT); 
  msg.type = 4; msg.data[0] = 'e'; msgsnd(msgId, &msg, 1, IPC_NOWAIT); 
  
  msgrcv(msgId, &msg, 1, -2, 0); putchar(msg.data[0]); 
  msgrcv(msgId, &msg, 1, 0, IPC_NOWAIT); putchar(msg.data[0]); 
  msgrcv(msgId, &msg, 1, 1, MSG_EXCEPT); putchar(msg.data[0]);
  msgrcv(msgId, &msg, 1, -5, 0); putchar(msg.data[0]); 
  msgrcv(msgId, &msg, 1, 4, IPC_NOWAIT); putchar(msg.data[0]); 
  msgrcv(msgId, &msg, 1, 7, MSG_EXCEPT); putchar(msg.data[0]);
  
  return 0;
}
```
### Вариант C

Предполагается, что обращение к функции вывода на экран прорабатывает атомарно и без буферизации. Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено. 

`msgId` – идентификатор существующей пустой очереди сообщений. Размер очереди - 5 сообщений

Напишите все возможные варианты вывода программы.

```c
int main() {
  
  struct { long type; char data[1]; } msg;
  msgId = msgget(IPC_PRIVATE, 0);

  if (fork()) {
    msg.type = 2; msg.data[0] = '1'; msgsnd(msgId, &msg, 1, 0); 
    msg.type = 2; msg.data[0] = '2'; msgsnd(msgId, &msg, 1, 0); 
    msg.type = 1; msg.data[0] = 'a'; msgsnd(msgId, &msg, 1, IPC_NOWAIT); 
    msg.type = 3; msg.data[0] = 'b'; msgsnd(msgId, &msg, 1, 0); 
    msg.type = 3; msg.data[0] = '5'; msgsnd(msgId, &msg, 1, 0); 
    msg.type = 1; msg.data[0] = '7'; msgsnd(msgId, &msg, 1, IPC_NOWAIT); 
    msg.type = 3; msg.data[0] = 'd'; msgsnd(msgId, &msg, 1, 0); 
    msg.type = 1; msg.data[0] = 'f'; msgsnd(msgId, &msg, 1, IPC_NOWAIT); 
    msg.type = 1; msg.data[0] = 'U'; msgsnd(msgId, &msg, 1, 0); 
  }
  
  msgrcv(msgId, &msg, 1, -2, 0); putchar(msg.data[0]); 
  msgrcv(msgId, &msg, 1, 1, IPC_NOWAIT); putchar(msg.data[0]); 
  msgrcv(msgId, &msg, 1, 1, MSG_EXCEPT); putchar(msg.data[0]);
  
  return 0;
}

```
## Задание №8

Что будет выведено на экран? Если возможны несколько вариантов, привести все. Все системные вызовы прорабатывают успешно. Подключение заголовочных файлов опущено. 
### Вариант А, B

```c
int main (void) { 
  pid_t pid; 
  int fd[2]; 
  char x[] = “abc”; 
  pipe(fd); 
  if ((pid = fork()) == 0) { 
    write(1, x, 1); 
    x[0] = ‘f’; 
    write(fd[1], x, 2); 
    x[0] = ‘s’; 
  } else { 
    read(fd[0], x, 2); 
    kill(pid, SIGKILL); 
    wait(NULL); 
  } 
  write(1, x, 1); 
  return 0; 
}
```
### Вариант C

```c
int main (void) { 
  pid_t pid; 
  int fd[2]; 
  char x[] = “abc”; 
  pipe(fd); 
  if ((pid = fork()) == 0) { 
    write(1, x, 1); 
    x[0] = ‘f’; 
    write(fd[1], x, 2); 
    x[0] = ‘s’; 
  } else { 
    kill(pid, SIGKILL); 
    read(fd[0], x, 2); 
  } 
  write(1, x, 1); 
  return 0; 
}
```

## Задача со звёздочкой

Иерархия
```
A
└── B
```

Код:
```c
int x = 3;

void hlr(int sig) {
  x = 5;
}

int main(int argc, char **argv)
{
  signal(SIGKILL, hlr);
  signal(SIGINT, hlr);

  int fd[2];
  pipe(fd);
  pid_t pid;

  int a = 4;
  if ((pid = fork()) == 0) {
    kill(getppid(), SIGINT);
    printf("%d\n", a);
    read(fd[0], &a, sizeof(a));
  } else {
    write(fd[1], &x, sizeof(x));
    kill(pid, SIGKILL);
  }

  printf("%d %d\n", getpid(), a);
  
  return 0;
}
```

Считаем, что printf работает атомарно и без буферизации и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы.

