В этом большом файлике будут собраны все подсказки и гайды по темам, которые появляются в задачнике Машечкина (кроме, быть может, теор.тем, которые уже описаны в Антологиях; тогда будем просто туда ссылаться)

По оглавлению можно удобно перемещаться между задачами и смотреть конкретно интересующие вас

В некоторых темах есть дополнительные материалы (помечены отдельным заголовком) и примеры, чтобы было проще понимать структуру. Дополнительные материалы используются в ***домашках***.

---


# Задача 1

```
"В оперативном запоминающем устройстве N-разрядного компьютера используется контроль целостности данных по чётности. 
Описать возможную структуру ячейки памяти и её побитовое содержимое для случая хранения в машинном слове числа"
```

***Решение:***

 + Переводим в `2-СС` (система счисления) число `M`, дополняем при необходимости нулями до `N` разрядов;
 + Считаем количество единиц: 
	 - Если нечётное, бит чётности(== бит паритета) объявляем равным единице, иначе нулём (его значение такое, чтобы вместе с ним `<сумма единичек> % 2 == 0`)

***Ответ вида:*** `<N бит числа M>, бит чётности равен <>`

---


# Задача 2

```
"Пусть дано число M, являющееся адресом оперативной памяти, расслоённой по N банкам.
Банку с каким номером принадлежит заданный адрес?"
```

***Решение:*** 

Число `M` в `2-СС` разбивается на две части по принципу `<offset><номер банка памяти>`.
Количество бит номера == округлённый _вверх_ двоичный логарифм от количества банков: 

$$
N_{bit} = \lceil{\log_2(N)}\rceil
$$

_Основные шаги:_

 + Переводим `M` в `2-СС`
 + Считаем $N_{bit}$ по количеству банков
 + Берём последние $N_{bit}$ бит получившегося числа
 + Переводим в `10-СС`, пишем его в ответ

**Важно:**

Обязательно в ответ явно дописываем фразу `"Нумерация банков начинается с нуля"`. 
Если вдруг в самом задании сказано считать банки с _единицы_, тогда в ответ пойдёт число на один больше получившегося

***Ответ вида:*** `Банк №<`$N_{bit}$` от числа M в 10-CC>, нумерация банков начинается с нуля`

---


# Задача 3

```
"Дан 32-хразрядный IP адрес, имеющий вид M. Определить:
	К какому классу относится данный IP адрес; 
	Номер сети в k-CC
	Номер хоста в g-CC
```

***Решение:***

_Класс сети_ определяется по первым битам его двоичного представления:
 + Класс `А` - IP начинается с `0...`
 + Класс `B` - IP начинается с `10...`
 + Класс `C` - IP начинается с `110...`
 + Класс `D` - IP начинается с `1110...`
 + Класс `E` - IP начинается с `1111...`

Классы отличаются побитовым разбиением на _часть Сети_ и _часть Хоста_. Общий вид IP: 
```
<Класс><Номер Сети><Номер Хоста>
```

 + Класс `А`: 1 бит класса(0) - 7 бит сети - 24 бита (3 байта) хоста
 + Класс `B`: 2 бита класса(10) - 14 бит сети - 16 бит (2 байта) хоста
 + Класс `C`: 3 бита класса(110) - 21 бит сети - 8 бит (1 байт) хоста

Не понадобятся почти наверное, но пусть будут:
 + Класс `D`: 4 бита класса(1110) - 28 бит номер группы
 + Класс `E`: 4 бита класса(1111) - 28 бит номер группы

_Основные шаги:_

 + Перевести `M` в `2-СС`
 + Определить класс по первым битам
 + В соответствии с классом разбить IP на части Сети и Хоста
 + Выписать в ответ необходимую вам часть в соответствии с форматом вывода

**Важно:**

Самое обидное при решении задачи будет плохо `сыграть в калькулятор`. При этом важно не только правильно перевести все части, но и промежуточные состояния писать верно. В частности, при переводе `M` в `2-СС` **проверяйте количество получившихся бит**. Будет реально грустно получить минус, за то, что у вас в двоичном представлении адреса будет 33 бита. И даже если вы этот лишний бит не учтёте и правильно без него всё посчитаете, _но не уберёте_, вам могут спокойно не зачесть всю задачу.

***Ответ вида:*** `Класс сети: <>, Номер сети: <В k-CC>, Номер хоста: <В g-CC>`

### Дополнительные материалы к Задаче 3

##### Представление даных

В обычной жизни мы привыкли пользоваться классической десятичной записью `IPv4`: каждый из четырёх  _октетов_ (8-битных блоков, из которых состоит IP) представляется в виде числа в диапазоне `[0:255]` и записывается через точку.
```
168.192.10.47
```

##### Маска сети

Для некоторых реальных задач неудобно разбивать сеть по классам. Н-р, для создания сети на $2^{17}$ хостов брать класс `А`, в котором $2^{24}$ хостов - как будто неблагодарное занятие. Поэтому в `IP` появилось понятие _маски сети_. \
Маска сети - это адрес, в котором первые `n` позиций единички, оставшиеся - нолики. Маска определяет части сети и хоста в `IP`-адресе соответственно размерам своих ненулевой и нулевой частей.  Благодаря маске мы можем задавать любые размеры сети под наши нужды. \
Маску можно указывать в классическом виде `IP`-адреса (н-р, для 18 бит сети маска имеет вид `255.255.192.0`) или приставкой `/N` к адресу 

Для определения минимальной маски сети, необходимой для поддержания N хостов, нужно помнить, что, внутри сети не все адреса могут быть присвоены пользователям. \
Хост `0...0` принадлежит сети (поэтому _адрес сети_ это адрес, где на месте хоста написаны нулевые биты)\
Хост `1...1` называется `BroadCast` и используется для отправки сообщения всем абонентам сети

Поэтому если на номер хоста выделено `N` бит, мы можем записать в него $2^N-2$ пользователей.




***Пример задачи с маской*** (будет в ***домашке***, почти наверное точно не будет в ОСях):

Задан IP-адрес в классическом формате с маской: `147.96.47.15/19`. Найти класс `сети без маски`, номер хоста `сети с маской` в 8-СС, IP-адрес сети

***Решение:***

Переведём `IP`-адрес в 2-СС: $10010011\ 01100000\ 00101111\ 00001111_2$

Первые биты адреса `10` - Класс В. \
Хост определяется $32-19=13$ битами, $0 111 100 001 111_2 = 7417_8$ \
`IP`-адрес сети будет выглядеть $10010011\ 01100000\ 001 \textbf{00000\ 00000000}_2$ = `147.96.32.0`

##### Подсети

Так как на пути пакета данных при его передаче встречается множество маршрутизаторов, на каждом из них можно задать какую-то свою маску под одну и ту же сеть, благодаря чему мы получаем биты адреса, определяющие нам уникальный идентификатор подсети. При этом на каждом маршрутизаторе у нас выделяются только Сеть и Хост, просто во всей структуре итоговый адрес можно логически разбить на более мелкие части.

Например, расмотрим жилой дом, в котором два подъезда. У каждого подъезда свой маршрутизатор, а также есть маршрутизатор всего дома. Если на маршрутизаторе дома стоит маска `/19`, то для описания адресов каждого подъезда можно использовать маску `/21`, тем самым выделяя в адресе два бита для однозначного определения подъезда $(2\ бита->2^2-2=2\ хоста\ можно\ описать)$ 

---


# Задача 4

```
"<Задана какая-то иерархия процессов, а также код с fork() и printf()>
Считаем, что printf работает атомарно и без буферизации и обращения ко всем системным вызовам успешно отрабатывают.
Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода 
в результате выполнения данной программы"
```

***Решение:***

К сожалению, из-за огромной вариативности одного универсального решения не существует. Однако вот несколько шагов, которые я предлагаю сделать, чтобы получить для себя информацию о том, что вообще может вывестись и есть ли у этого зависимости, а также немного доп.инфо:
 
 + _Распишите полный цикл жизни каждого процесса_, которые возникают в программе. Нас будут интересовать выводы (`printf`-ы и не только), выпишите для каждого процесса отдельно, что он вообще может выводить и в какой последовательности. Помните, что исполнение кода внутри одного процесса строго последовательное, поэтому выводы от одного процесса зависимы друг от друга (печатаются по очереди)

 + _Посмотрите зависимости между процессами_. Может, какие-то из них не могут выполнить какой-то кусок кода, пока что-то не произойдёт в другом процессе (например, `wait` заблокировал родительский процесс до того, пока какой-нибудь из сыновьих не закончит работу и не разблокирует отца)

 + Отсеяв совсем уж невозможные варианты предыдущими пунктами, _переберите все возможные варианты комбинаторики имеющихся процессов_ и для каждого случая выпишите их `printf` в этой очерёдности. Почти наверное всегда вы уже получили все ответы, однако среди них могут быть
	 - _Повторяющиеся_, надо будет убрать лишнее, 
	 - _Также невозможные_, но из каких-то неочевидных комбинаций. \
   Собрав такой список возможных выводов попробуйте пройтись по программе и найти ту последовательность действий, при которой такой вывод возможен. Если такой нет, значит и вывода такого быть не может

**Важно:**
 + При создании процесса через `fork()` в новом процессе создаётся собственное пространство имён, куда копируются все значения из родительского. Однако это два _независимых_ пространства. _Изменение в одном != изменение в обоих_
 + _wait()_ ждёт окончания `1. только одного` `2. своего сыновьего` процесса. После чего блокировка спадает
 + `getppid()` возвращает номер родительского `pid`, пока тот существует, и `1`(номер процесса `INIT`), когда родительский завершился

***Пример разбора задачи:***

*Пусть процесс с `PID A` породил два сыновьих процесса с `PID`-ами `B` и `C`:* 
```c
int main(int argc, char **argv) // PID = A
{
	if (fork() == 0) { // PID = B
		printf ("%d %d \n", getppid(), getpid());
		_exit(0);
	} 
	if (fork() == 0) { // PID = C
		printf ("%d \n", getpid());
		_exit(0);
		}
	return 0;
}
```
*Считаем, что `printf` работает атомарно и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы.*

Для начала разберёмся, что делает каждый процесс:
 + А просто создаёт двух сыновей, после чего **завершается без ожидания**, никаких выводов не делает;
 + В, создавшись первым `fork`-ом, печатает `getppid` (зависимый от А), и свой `PID`:
	 - `<getppid[A]> B` \
После чего завершается
+ C, создавшись вторым `fork`-ом, просто печатает свой `PID`:
	 - `С` \
После чего завершается

Теперь посмотрим, есть ли у нас зависимые _между процессами_ выводы. Да, есть: С печатает всё однозначно, а вот В напечатает `ppid` A, если он ещё не успел к этому моменту завершиться, и `1`, если успел. Поэтому вывод B разбивается на два варианта:
 - `А В`
 - `1 В`

Теперь переберём все возможные комбинации печати:
 + Если сначала печатает В, потом С; А **не успел** завершиться:
   ```
   A B
   C
   ```
 + Если сначала печатает В, потом С; А **успел** завершиться:
   ```
   1 B
   C
   ```
 + Если сначала печатает C, потом В; А **не успел** завершиться:
   ```
   C
   A B
   ```
 + Если сначала печатает C, потом B; А **успел** завершиться:
   ```
   C
   1 B
   ```

Это и есть все возможные выводы программы



***Пример разбора задачи:***

*Пусть процесс с `PID A` породил сыновий процесс с `PID B` :* 
```c
int main(int argc, char **argv) //PID = A
{
	int n = 42;
	if (fork() == 0) { //PID = B
		printf ("%d %d %d \n", n, getppid(), getpid());
		n = 8;
		_exit(0);
	}
	n = 10;
	printf ("%d %d \n", n, getpid());
	return 0;
}
```

*Считаем, что `printf` работает атомарно, без буферизации, и обращения ко всем системным вызовам успешно отрабатывают. Перечислить все возможные комбинации значений, которые могут быть выведены на стандартное устройство вывода в результате выполнения данной программы.*

_Посмотрим, что делает каждый процесс:_
 + А со значением `n = 42` создаёт сыновий процесс, после чего меняет значение `n = 10`и печатает его и свой `PID`:
	 - `10 А`
 + В создаётся с `n = 42`, печатает его, `getppid` (зависимый от А), и свой `PID`:
	 - `42 <getppid[A]> B` \
Отсюда, кстати, ясно, что строка `n = 8` фиктивная; она никак не повлияет на печать А (разные процессы -> разные виртуальные адресные пространства), а для B она уже ничего не меняет.

_Зависимости вывода:_
Т.к. А завершается без ожидания, для печати B существует два варианта:
- `42 А В`
- `42 1 В`

_Переберём варианты вывода:_
 + Если сначала печатает A, потом B; А **не успел** завершиться:
   ```
   10 А
   42 A B
   ```
 + Если сначала печатает A, потом B; А **успел** завершиться:
   ```
   10 А
   42 1 B
   ```
 + Если сначала печатает B, потом A; А **не может завершиться раньше** (он ещё ничего не печатал, программа не могла завершиться физически), поэтому вариант всего один:
   ```
   42 А B
   10 A
   ```




***Пример разбора задачи (усложнённый):***

Условие, как и выше, но изменён код:

```c
int main(int argc, char **argv) //PID = A
{
	int n = 42;
	if (fork() == 0) { //PID = B
		printf ("%d %d %d \n", n, getppid(), getpid());
		n = 8;
		// убрали здесь exit(0)
	}
	n = 10;
	printf ("%d %d \n", n, getpid());
	return 0;
}
```

На работу А это никак не повлияло, а вот B по завершении первого вывода выйдет из `if`, поменяет `n = 10` и напечатает `10 B`. Итого полный вывод В:
- `42 А В` или `42 1 B`
- `10 В`

Порядок печати в B определён, а вот вывод А относительно В может быть как _до обеих строк от В_, так и _между ними_ или _после них_. При этом только в случае, когда А печатает первый, возможно два варианта для вывода первой строки от В. В других случаях вывод будет однозначный: `42 А В`

Итого, полный ответ:

```
10 А
42 А B
10 В

10 А
42 1 B
10 В

42 А B
10 А
10 В

42 А B
10 В
10 А
```
